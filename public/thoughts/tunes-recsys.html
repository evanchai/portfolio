<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="用一个 LLM 替代整个推荐系统：Tunes 个人音乐推荐系统的从 0 到 1 搭建记录。" />
  <title>LLM-as-RecSys — Ning</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,200;0,9..144,300;0,9..144,400;0,9..144,600;1,9..144,200;1,9..144,300;1,9..144,400&family=Noto+Sans+SC:wght@200;300;400;500&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">

  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #f0ebe4; --bg2: #e7e0d6; --card: #f6f2ec;
      --text: #2e2b26; --text-2: #6d665c; --text-3: #a69e94;
      --olive: #5e7050; --olive-light: #7a9469; --olive-bg: rgba(94,112,80,0.07);
      --line: #d4ccc2; --coral: #ff4d6a; --coral-bg: rgba(255,77,106,0.07);
      --serif: 'Fraunces', 'Noto Sans SC', 'PingFang SC', sans-serif;
      --mono: 'Space Mono', monospace;
      --sans: 'Noto Sans SC', 'PingFang SC', -apple-system, sans-serif;
    }
    html { height: 100%; scroll-behavior: smooth; }
    body { background: var(--bg); color: var(--text); font-family: var(--sans); font-size: 15px; line-height: 1.9; -webkit-font-smoothing: antialiased; min-height: 100%; }
    ::selection { background: var(--olive); color: #fff; }
    .page { max-width: 720px; margin: 0 auto; padding: 0 2rem; }

    .back-link { display: flex; justify-content: flex-end; padding: 2rem 0 0; }
    .back-link a { font-family: var(--mono); font-size: 0.7rem; color: var(--text-3); text-decoration: none; letter-spacing: 0.05em; transition: color 0.3s; }
    .back-link a:hover { color: var(--olive); }

    .article-header { padding: 3rem 0 2rem; border-bottom: 1px solid var(--line); margin-bottom: 3rem; }
    .article-meta { font-family: var(--mono); font-size: 0.62rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--text-3); margin-bottom: 1.5rem; display: flex; gap: 1.5rem; flex-wrap: wrap; }
    .article-header h1 { font-family: var(--serif); font-weight: 200; font-size: clamp(2rem, 5vw, 3rem); line-height: 1.2; letter-spacing: -0.02em; margin-bottom: 1.2rem; }
    .article-header h1 em { font-style: italic; font-weight: 300; color: var(--olive); }
    .article-lead { font-family: var(--serif); font-size: 1.15rem; font-weight: 300; line-height: 1.8; color: var(--text-2); max-width: 56ch; }
    .article-tags { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
    .article-tag { font-family: var(--mono); font-size: 0.6rem; color: var(--olive); letter-spacing: 0.04em; }

    .toc { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 1.8rem 2rem; margin-bottom: 3rem; }
    .toc-title { font-family: var(--mono); font-size: 0.62rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--text-3); margin-bottom: 1rem; }
    .toc ol { list-style: none; counter-reset: toc; }
    .toc li { counter-increment: toc; padding: 0.2rem 0; }
    .toc li::before { content: counter(toc, decimal-leading-zero); font-family: var(--mono); font-size: 0.65rem; color: var(--text-3); margin-right: 0.8rem; }
    .toc a { font-family: var(--serif); font-size: 0.95rem; font-weight: 300; color: var(--text); text-decoration: none; transition: color 0.3s; }
    .toc a:hover { color: var(--olive); }

    .article-body h2 { font-family: var(--serif); font-weight: 300; font-size: 1.7rem; line-height: 1.3; margin: 3.5rem 0 1rem; padding-top: 1rem; }
    .article-body h2 em { font-style: italic; color: var(--olive); }
    .article-body h3 { font-family: var(--serif); font-weight: 400; font-size: 1.15rem; margin: 2.5rem 0 0.8rem; }
    .article-body p { margin-bottom: 1.2rem; color: var(--text-2); }
    .article-body strong { color: var(--text); font-weight: 500; }
    .article-body a { color: var(--olive); text-decoration: underline; text-decoration-color: var(--line); text-underline-offset: 3px; transition: text-decoration-color 0.3s; }
    .article-body a:hover { text-decoration-color: var(--olive); }
    .article-body code { font-family: var(--mono); font-size: 0.82em; background: var(--bg2); border-radius: 4px; padding: 0.15em 0.45em; }
    .article-body ol, .article-body ul { margin: 0.8rem 0 1.5rem 1.5rem; color: var(--text-2); }
    .article-body li { margin-bottom: 0.4rem; padding-left: 0.3rem; }

    .code-block { background: #2e2b26; color: #e8e0d6; border-radius: 12px; padding: 1.4rem 1.6rem; font-family: var(--mono); font-size: 0.72rem; line-height: 1.9; overflow-x: auto; margin: 1.5rem 0 2rem; }
    .code-block .cm { color: #7a7568; } .code-block .kw { color: #a3c486; } .code-block .str { color: #d4a96a; }
    .code-block .fn { color: #88b4d4; } .code-block .tp { color: #c4a3ff; } .code-block .coral { color: #ffa3b3; }

    .callout { background: var(--card); border: 1px solid var(--line); border-left: 3px solid var(--olive); border-radius: 0 12px 12px 0; padding: 1.2rem 1.4rem; margin: 1.5rem 0 2rem; font-size: 0.88rem; color: var(--text-2); line-height: 1.8; }
    .callout.coral { border-left-color: var(--coral); }
    .callout b { color: var(--olive); } .callout.coral b { color: var(--coral); }

    .diagram { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 1.8rem; margin: 1.5rem 0 2rem; font-family: var(--mono); font-size: 0.72rem; line-height: 1.8; overflow-x: auto; white-space: pre; color: var(--text-2); }
    .diagram .hl { color: var(--olive); font-weight: 700; } .diagram .dim { color: var(--text-3); }

    .article-table { width: 100%; border-collapse: collapse; margin: 1.5rem 0 2rem; font-size: 0.82rem; }
    .article-table th { font-family: var(--serif); font-weight: 400; font-size: 0.9rem; text-align: left; padding: 1rem; border-bottom: 2px solid var(--line); }
    .article-table td { padding: 0.7rem 1rem; border-bottom: 1px solid var(--line); color: var(--text-2); line-height: 1.7; vertical-align: top; }
    .article-table tr:hover td { background: var(--olive-bg); }
    .article-table .win { color: var(--olive); font-weight: 700; } .article-table .lose { color: var(--text-3); }

    .insight-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0 2rem; }
    .insight-card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 1.4rem 1.5rem; transition: all 0.35s; }
    .insight-card:hover { transform: translateY(-3px); border-color: var(--olive-light); box-shadow: 0 12px 36px rgba(46,43,38,0.05); }
    .insight-card h4 { font-family: var(--serif); font-weight: 400; font-size: 0.95rem; margin-bottom: 0.5rem; }
    .insight-card p { font-size: 0.78rem; color: var(--text-2); line-height: 1.8; margin: 0; }

    .step-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0 2rem; }
    .step-card { background: var(--card); border: 1px solid var(--line); border-radius: 14px; padding: 1.4rem 1.5rem; transition: all 0.35s; }
    .step-card:hover { transform: translateY(-3px); border-color: var(--olive-light); box-shadow: 0 12px 36px rgba(46,43,38,0.05); }
    .step-num { font-family: var(--mono); font-size: 0.6rem; color: var(--olive); letter-spacing: 0.1em; margin-bottom: 0.4rem; }
    .step-card h4 { font-family: var(--serif); font-weight: 400; font-size: 0.95rem; margin-bottom: 0.3rem; }
    .step-card p { font-size: 0.78rem; color: var(--text-2); line-height: 1.7; margin: 0; }

    .section-divider { border: none; border-top: 1px solid var(--line); margin: 3rem 0; }

    .page-footer { border-top: 1px solid var(--line); padding: 1.5rem 0 3rem; display: flex; justify-content: space-between; align-items: center; font-family: var(--mono); font-size: 0.62rem; color: var(--text-3); letter-spacing: 0.04em; margin-top: 4rem; }
    .page-footer .made { display: flex; align-items: center; gap: 0.5rem; }
    .page-footer .heart { display: inline-block; width: 5px; height: 5px; border-radius: 50%; background: var(--olive); }

    /* ── Language Toggle ── */
    .lang-toggle { position: fixed; top: 2rem; right: 2rem; font-family: var(--mono); font-size: 0.65rem; letter-spacing: 0.08em; padding: 0.4rem 1rem; border: 1px solid var(--line); border-radius: 100px; background: var(--card); color: var(--text-2); cursor: pointer; transition: all 0.3s; z-index: 50; }
    .lang-toggle:hover { border-color: var(--olive); color: var(--olive); }
    .en { display: none; }
    html.lang-en .zh { display: none; }
    html.lang-en .en { display: revert; }

    .rv { opacity: 0; transform: translateY(18px); transition: opacity 0.7s ease, transform 0.7s ease; }
    .rv.v { opacity: 1; transform: translateY(0); }

    @media (max-width: 600px) {
      .page { padding: 0 1.2rem; }
      .article-header { padding: 2rem 0 1.5rem; margin-bottom: 2rem; }
      .article-header h1 { font-size: clamp(1.6rem, 7vw, 2.2rem); }
      .article-lead { font-size: 1rem; }
      .article-body h2 { font-size: 1.4rem; margin-top: 2.5rem; }
      .step-grid, .insight-grid { grid-template-columns: 1fr; }
      .article-table { font-size: 0.72rem; }
      .article-table th, .article-table td { padding: 0.5rem 0.6rem; }
      .page-footer { flex-direction: column; gap: 0.5rem; }
      .toc { padding: 1.4rem 1.5rem; }
      .lang-toggle { top: 1rem; right: 1rem; }
    }
  </style>
</head>
<body>
<div class="page">
  <div class="back-link"><a href="/thoughts">← thoughts</a></div>
  <button class="lang-toggle" id="langToggle">EN</button>

  <header class="article-header rv">
    <div class="article-meta"><span>Mar 2025</span><span>Ning</span><span>~15 min</span></div>
    <h1 class="zh">LLM-as-RecSys：<br>从 0 到 1 搭建个人<em>音乐推荐</em>系统</h1>
    <h1 class="en">LLM-as-RecSys:<br>Building a Personal Music <em>Recommendation</em> System from Scratch</h1>
    <p class="article-lead zh">不需要协同过滤、不需要 embedding、不需要训练数据。用一个 LLM + 一段 playlist + 持续的听歌行为，就能搭建一个越用越懂你的推荐系统。</p>
    <p class="article-lead en">No collaborative filtering, no embeddings, no training data. Just an LLM, a playlist, and continuous listening behavior to build a recommendation system that gets better over time.</p>
    <div class="article-tags">
      <span class="article-tag">#ai</span><span class="article-tag">#recsys</span><span class="article-tag">#music</span><span class="article-tag">#vibe-coding</span>
    </div>
  </header>

  <nav class="toc rv">
    <div class="toc-title">Table of Contents</div>
    <ol class="zh">
      <li><a href="#idea">核心理念：为什么用 LLM 做推荐</a></li>
      <li><a href="#data-model">定义数据模型</a></li>
      <li><a href="#taste">品味提取：一个 playlist 的信息量</a></li>
      <li><a href="#engine">推荐引擎：Prompt 就是算法</a></li>
      <li><a href="#feedback">反馈闭环：让系统越用越聪明</a></li>
      <li><a href="#playback">播放与搜索</a></li>
      <li><a href="#persistence">数据持久化</a></li>
      <li><a href="#prompt-eng">Prompt 工程笔记</a></li>
      <li><a href="#tradeoffs">Trade-offs</a></li>
      <li><a href="#conclusion">总结</a></li>
    </ol>
    <ol class="en">
      <li><a href="#idea">Core Idea: Why Use an LLM for Recommendations</a></li>
      <li><a href="#data-model">Defining the Data Model</a></li>
      <li><a href="#taste">Taste Extraction: Information in a Playlist</a></li>
      <li><a href="#engine">The Recommendation Engine: Prompt as Algorithm</a></li>
      <li><a href="#feedback">The Feedback Loop</a></li>
      <li><a href="#playback">Playback & Search</a></li>
      <li><a href="#persistence">Data Persistence</a></li>
      <li><a href="#prompt-eng">Prompt Engineering Notes</a></li>
      <li><a href="#tradeoffs">Trade-offs</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ol>
  </nav>

  <article class="article-body">

    <h2 id="idea" class="rv zh">核心理念：为什么用 LLM 做<em>推荐</em></h2>
    <h2 id="idea" class="rv en">Core Idea: Why Use an LLM for <em>Recommendations</em></h2>

    <p class="rv zh">传统推荐系统的搭建流程：收集大量用户行为数据 → 特征工程 → 训练模型 → 召回 → 排序 → 推荐。这条路对大公司有意义，但对个人项目来说是 overkill。</p>
    <p class="rv en">The traditional recommendation system pipeline: collect massive user behavior data → feature engineering → train models → recall → ranking → recommend. This makes sense for big companies, but it's overkill for a personal project.</p>

    <div class="diagram rv"><span class="dim zh">传统路线</span><span class="dim en">Traditional</span>
User logs → Features → Training → Recall → Ranking → Recommend

<span class="dim">Tunes</span>
Playlist → <span class="hl">LLM analyzes taste</span> → Behavior → <span class="hl">Inject into prompt</span> → LLM recommends → Loop</div>

    <p class="rv zh">这条路之所以可行，靠的是三个洞察：</p>
    <p class="rv en">This approach works because of three key insights:</p>

    <ol class="rv zh">
      <li><strong>LLM 天生具备音乐知识。</strong> Gemini 在训练时已经"见过"海量乐评和歌单，它知道 LANY 的风格接近 The 1975 而不是 Metallica。</li>
      <li><strong>自然语言是最灵活的特征编码。</strong> 不需要 one-hot encoding 或向量化，直接写 "dreamy indie pop with nostalgic vibes" 比任何 embedding 更精确。</li>
      <li><strong>Prompt 是实时可调的。</strong> 不需要重新训练，改一行 prompt 就能改变推荐策略。</li>
    </ol>
    <ol class="rv en">
      <li><strong>LLMs inherently know music.</strong> Gemini has "seen" vast amounts of music reviews and playlists during training — it knows LANY's style is closer to The 1975 than Metallica.</li>
      <li><strong>Natural language is the most flexible feature encoding.</strong> No one-hot encoding or vectorization needed — just write "dreamy indie pop with nostalgic vibes" and it's more precise than any embedding.</li>
      <li><strong>Prompts are adjustable in real-time.</strong> No retraining needed — change one line and the recommendation strategy shifts.</li>
    </ol>

    <hr class="section-divider">

    <h2 id="data-model" class="rv zh">定义<em>数据模型</em></h2>
    <h2 class="rv en">Defining the <em>Data Model</em></h2>

    <p class="rv zh">整个推荐系统只需要三个核心类型。不多也不少。</p>
    <p class="rv en">The entire recommendation system needs just three core types. No more, no less.</p>

    <h3 class="rv">TasteProfile</h3>
    <div class="code-block rv"><span class="tp">TasteProfile</span> {
  <span class="fn">genres</span>:      <span class="str">["Pop", "R&B", "Indie Pop", "Hip-Hop", "C-Pop"]</span>
  <span class="fn">moods</span>:       <span class="str">["Nostalgic", "Romantic", "Chill", "Melancholy"]</span>
  <span class="fn">eras</span>:        <span class="str">["2000s", "2010s", "2020s"]</span>
  <span class="fn">energyLevel</span>: <span class="str">"Medium — mix of chill vibes and upbeat grooves"</span>
  <span class="fn">summary</span>:     <span class="str">"Multilingual listener with a strong taste for smooth R&B..."</span>
  <span class="fn">summaryCn</span>:   <span class="str">"多语言听众，偏爱丝滑 R&B、梦幻独立流行..."</span>
}</div>

    <p class="rv zh">多维度建模（风格、情绪、年代、能量）比单一标签更精确。自由文本的 <code>summary</code> 让 AI 有空间表达复杂品味。双语 summary 支持中英文 UI。</p>
    <p class="rv en">Multi-dimensional modeling (genre, mood, era, energy) is far more precise than single labels. The free-text <code>summary</code> gives AI room to express complex taste patterns. Bilingual summaries support both CN/EN UI.</p>

    <h3 class="rv">SongFeedback</h3>
    <div class="code-block rv"><span class="tp">SongFeedback</span> {
  <span class="fn">listenDurationSec</span>: <span class="str">240</span>   <span class="cm">// how long they actually listened</span>
  <span class="fn">songDurationSec</span>:   <span class="str">240</span>   <span class="cm">// total song length</span>
  <span class="fn">liked</span>:             <span class="str">true</span>  <span class="cm">// hearted?</span>
}</div>

    <div class="callout rv">
      <b class="zh">设计原则：</b><b class="en">Design principle:</b>
      <span class="zh">不做显式评分（1-5 星），完全依赖隐式信号。收听时长占比是核心信号：<code>&ge;50%</code> = 喜欢，<code>&lt;50%</code> = 跳过。<code>liked</code> 是额外的强信号。零摩擦的数据采集。</span>
      <span class="en">No explicit ratings (1-5 stars). Entirely implicit signals. Listen duration ratio is the core signal: <code>&ge;50%</code> = enjoyed, <code>&lt;50%</code> = skipped. <code>liked</code> is a bonus strong signal. Zero-friction data collection.</span>
    </div>

    <hr class="section-divider">

    <h2 id="taste" class="rv zh">品味提取：一个 playlist 的<em>信息量</em></h2>
    <h2 class="rv en">Taste Extraction: The <em>Information</em> in a Playlist</h2>

    <p class="rv zh">用户的输入极其简单——从 Spotify、Apple Music 或 YouTube Music 复制粘贴自己的歌单。文本可能很乱，格式各异。AI 负责从中解析。</p>
    <p class="rv en">User input is dead simple — copy-paste a playlist from Spotify, Apple Music, or YouTube Music. The text may be messy and inconsistently formatted. The AI handles parsing.</p>

    <p class="rv zh">初始化时，一次 Gemini 调用同时完成两件事：分析品味 + 生成推荐。关键技术是 <strong>Structured Output</strong>——用 <code>responseSchema</code> 强制约束输出格式：</p>
    <p class="rv en">During initialization, a single Gemini call does two things at once: analyze taste + generate recommendations. The key technique is <strong>Structured Output</strong> — using <code>responseSchema</code> to enforce output format:</p>

    <div class="code-block rv"><span class="cm">// Gemini API call config</span>
<span class="kw">const</span> response = <span class="kw">await</span> ai.models.<span class="fn">generateContent</span>({
  model: <span class="str">"gemini-2.0-flash"</span>,
  contents: prompt,
  config: {
    responseMimeType: <span class="str">"application/json"</span>,
    responseSchema: RECOMMEND_SCHEMA,  <span class="cm">// enforced structure</span>
    temperature: <span class="coral">0.9</span>,                  <span class="cm">// high creativity</span>
    maxOutputTokens: <span class="coral">4096</span>,
  },
});</div>

    <div class="callout coral rv">
      <b class="zh">为什么 temperature = 0.9？</b><b class="en">Why temperature = 0.9?</b>
      <span class="zh">推荐系统需要多样性。太低的话 AI 每次推荐相同的"安全"歌曲。0.9 在保持相关性的同时引入足够随机性——像一个有品味但不无聊的 DJ。</span>
      <span class="en">Recommendation systems need diversity. Too low and the AI recommends the same "safe" songs every time. 0.9 balances relevance with enough randomness — like a DJ with taste who isn't boring.</span>
    </div>

    <hr class="section-divider">

    <h2 id="engine" class="rv zh">推荐引擎：Prompt 就是<em>算法</em></h2>
    <h2 class="rv en">The Rec Engine: Prompt as <em>Algorithm</em></h2>

    <p class="rv zh">核心创新：把用户行为数据直接编码成自然语言，注入到 prompt 中。这让一个无状态的 LLM 变成了有状态的推荐引擎。</p>
    <p class="rv en">The core innovation: encode user behavior directly as natural language and inject it into the prompt. This turns a stateless LLM into a stateful recommendation engine.</p>

    <div class="code-block rv"><span class="cm">// Adaptive prompt structure</span>

<span class="kw">TASTE PROFILE:</span>
- Genres: Pop, R&B, Indie Pop, Synth-Pop, C-Pop
- Moods: Nostalgic, Romantic, Chill

<span class="kw">SONGS THEY ENJOYED</span> (listened longer):
  <span class="str">"LANY - Dancing in the Kitchen"</span> (240s/240s, liked)
  <span class="str">"The Weeknd - Save Your Tears"</span> (200s/220s)

<span class="kw">SONGS THEY SKIPPED:</span>
  <span class="str">"Unknown - Sad Indie Ballad"</span> (45s/200s)

<span class="kw">INSTRUCTIONS:</span>
  1. Recommend 10 NEW songs:
     - Enjoyed → <span class="fn">recommend more like those</span>
     - Skipped → <span class="fn">avoid that style/mood</span>
  2. Do NOT repeat any already played songs</div>

    <div class="insight-grid zh">
      <div class="insight-card rv">
        <h4>Profile 不可变</h4>
        <p>Taste profile 提取一次后就不再更新。如果让 AI 每轮修改 profile，会导致「品味漂移」——连续跳几首慢歌，"Chill" 标签就消失。行为调节靠 feedback，不靠改 profile。</p>
      </div>
      <div class="insight-card rv">
        <h4>完整播放列表</h4>
        <p>把所有已播放歌曲都传进 prompt。试过只传最近 N 首，但 AI 会重复推荐。对个人使用（&lt;100 首），token 成本可忽略。</p>
      </div>
      <div class="insight-card rv">
        <h4>时长比例是信号</h4>
        <p><code>(240s/240s, liked)</code> 比单纯 "enjoyed" 信息量大得多。AI 能区分"听完了"和"听完了还点赞"。</p>
      </div>
      <div class="insight-card rv">
        <h4>容错设计</h4>
        <p>当 <code>songDurationSec === 0</code>（YouTube 偶尔不报告时长）时，默认归类为"喜欢"。False positive 比 false negative 伤害小。</p>
      </div>
    </div>
    <div class="insight-grid en">
      <div class="insight-card rv">
        <h4>Immutable Profile</h4>
        <p>The taste profile is extracted once and never updated. Letting AI modify it each round causes "taste drift" — skip a few slow songs and the "Chill" tag disappears forever. Behavior steers via feedback, not profile changes.</p>
      </div>
      <div class="insight-card rv">
        <h4>Full Played List</h4>
        <p>All played songs are sent in the prompt. Tried sending only the last N, but the AI would repeat songs from earlier rounds. For personal use (&lt;100 songs), token cost is negligible.</p>
      </div>
      <div class="insight-card rv">
        <h4>Duration Ratio as Signal</h4>
        <p><code>(240s/240s, liked)</code> carries far more information than just "enjoyed". The AI can distinguish "listened through" from "listened through AND hearted".</p>
      </div>
      <div class="insight-card rv">
        <h4>Graceful Fallback</h4>
        <p>When <code>songDurationSec === 0</code> (YouTube sometimes doesn't report duration), default to "enjoyed". False positives hurt less than false negatives.</p>
      </div>
    </div>

    <hr class="section-divider">

    <h2 id="feedback" class="rv zh">反馈闭环：让系统<em>越用越聪明</em></h2>
    <h2 class="rv en">The Feedback Loop: Getting <em>Smarter</em> Over Time</h2>

    <p class="rv zh">推荐系统的价值不在首次推荐，而在持续学习。Tunes 的反馈闭环完全自动化——用户只需要正常听歌。</p>
    <p class="rv en">A recommendation system's value isn't in the first batch — it's in continuous learning. Tunes' feedback loop is fully automated — users just listen to music.</p>

    <div class="diagram rv"><span class="hl zh">完整循环</span><span class="hl en">Full cycle</span>

1. User listens → YouTube reports events
2. Song ends or user skips → <span class="hl">recordFeedback()</span>
3. Feedback recorded: duration, liked status
4. Queue &lt; 10 songs → auto-trigger <span class="hl">fetchMore()</span>
5. Gemini receives: profile + feedback + played list
6. Returns 10 new songs → added to queue
7. Back to step 1</div>

    <h3 class="rv zh">50% 阈值的由来</h3>
    <h3 class="rv en">Why the 50% Threshold</h3>

    <p class="rv zh">反馈分类的阈值经过实际使用校准：</p>
    <p class="rv en">The classification threshold was calibrated through real usage:</p>

    <ul class="rv zh">
      <li><strong>&lt; 30%</strong>：太严格。很多"听了一半觉得还行"的歌被算成跳过</li>
      <li><strong>50%</strong>：直觉上"听了一半"说明至少不讨厌。实测效果最好</li>
      <li><strong>&gt; 70%</strong>：太宽松。有些歌只是来不及跳过就被算成喜欢</li>
    </ul>
    <ul class="rv en">
      <li><strong>&lt; 30%</strong>: Too strict. Many "listened halfway and thought it was fine" songs get classified as skipped</li>
      <li><strong>50%</strong>: Intuitively, "listened to half" means at least tolerable. Best results in practice</li>
      <li><strong>&gt; 70%</strong>: Too lenient. Some songs just weren't skipped in time</li>
    </ul>

    <h3 class="rv zh">队列预取</h3>
    <h3 class="rv en">Queue Pre-fetching</h3>

    <p class="rv zh">当队列剩余不足 10 首时，自动触发新的 Gemini 调用。用户永远不需要等——下一批歌在当前批次播放时就已准备好。</p>
    <p class="rv en">When the queue drops below 10 songs, a new Gemini call fires automatically. Users never wait — the next batch is ready before the current one finishes.</p>

    <hr class="section-divider">

    <h2 id="playback" class="rv zh">播放与<em>搜索</em></h2>
    <h2 class="rv en">Playback & <em>Search</em></h2>

    <p class="rv zh">Gemini 返回的每首歌都带有一个 <code>searchQuery</code>（格式 "Artist - Song Title"）。播放前需要解析为 YouTube 视频 ID。</p>
    <p class="rv en">Each song from Gemini includes a <code>searchQuery</code> (format: "Artist - Song Title"). Before playback, this needs to be resolved to a YouTube video ID.</p>

    <div class="step-grid zh">
      <div class="step-card rv"><div class="step-num">STEP 01</div><h4>YouTube Data API 搜索</h4><p>发送 searchQuery，限定 <code>videoCategoryId: "10"</code>（音乐）+ <code>videoEmbeddable: true</code>。</p></div>
      <div class="step-card rv"><div class="step-num">STEP 02</div><h4>缓存 videoId</h4><p>首次解析后把 videoId 写回 song 对象。后续重播直接使用。</p></div>
      <div class="step-card rv"><div class="step-num">STEP 03</div><h4>IFrame 播放</h4><p>YouTube IFrame API 播放视频，监听 <code>onStateChange</code> 获取播放状态和时长。</p></div>
      <div class="step-card rv"><div class="step-num">STEP 04</div><h4>采集反馈</h4><p>播放完毕或用户跳过时，记录 <code>listenDurationSec</code> 和 <code>songDurationSec</code>。</p></div>
    </div>
    <div class="step-grid en">
      <div class="step-card rv"><div class="step-num">STEP 01</div><h4>YouTube Data API Search</h4><p>Send searchQuery, filter by <code>videoCategoryId: "10"</code> (Music) + <code>videoEmbeddable: true</code>.</p></div>
      <div class="step-card rv"><div class="step-num">STEP 02</div><h4>Cache videoId</h4><p>After first resolution, write videoId back to the song object. Subsequent plays reuse it.</p></div>
      <div class="step-card rv"><div class="step-num">STEP 03</div><h4>IFrame Playback</h4><p>YouTube IFrame API plays the video, <code>onStateChange</code> events report play state and duration.</p></div>
      <div class="step-card rv"><div class="step-num">STEP 04</div><h4>Collect Feedback</h4><p>When song ends or user skips, record <code>listenDurationSec</code> and <code>songDurationSec</code>.</p></div>
    </div>

    <div class="callout rv">
      <b class="zh">为什么不用 Spotify API？</b><b class="en">Why not Spotify API?</b>
      <span class="zh">Spotify Web Playback 需要 Premium 账号 + OAuth。YouTube 免费、覆盖率接近 100%、IFrame API 事件系统完善。</span>
      <span class="en">Spotify Web Playback requires Premium + OAuth. YouTube is free, covers nearly 100% of songs, and has excellent IFrame API events.</span>
    </div>

    <hr class="section-divider">

    <h2 id="persistence" class="rv zh">数据持久化：不丢一个<em>反馈</em></h2>
    <h2 class="rv en">Data Persistence: Never Lose a <em>Beat</em></h2>

    <p class="rv zh">驾驶场景意味着随时可能断网、锁屏、关闭 app。同步策略必须足够健壮。</p>
    <p class="rv en">Driving means unpredictable connectivity. The sync strategy must be robust enough to handle tab closes, screen locks, and network drops.</p>

    <div class="insight-grid zh">
      <div class="insight-card rv"><h4>防抖保存</h4><p>每次反馈事件触发 2 秒防抖。快速跳过批量合并为一次 Redis 写入。</p></div>
      <div class="insight-card rv"><h4>visibilitychange</h4><p>切 tab 或锁屏时立即保存。覆盖「手机放进口袋」场景。</p></div>
      <div class="insight-card rv"><h4>sendBeacon 兜底</h4><p><code>beforeunload</code> 时用 <code>sendBeacon()</code> 发最终保存。页面销毁也能送达。</p></div>
      <div class="insight-card rv"><h4>队列缓存</h4><p>待播列表持久化到 Redis。下次打开直接从缓存加载，无需等 Gemini。</p></div>
    </div>
    <div class="insight-grid en">
      <div class="insight-card rv"><h4>Debounced Save</h4><p>Each feedback event triggers a 2-second debounce. Rapid skips batch into a single Redis write.</p></div>
      <div class="insight-card rv"><h4>visibilitychange</h4><p>Immediate save when switching tabs or locking the screen. Covers the "phone in pocket" scenario.</p></div>
      <div class="insight-card rv"><h4>sendBeacon Fallback</h4><p>On <code>beforeunload</code>, <code>sendBeacon()</code> fires a final save. Works even when the page is being destroyed.</p></div>
      <div class="insight-card rv"><h4>Cached Queue</h4><p>Upcoming songs persist to Redis. Next session loads instantly from cache — no Gemini call needed.</p></div>
    </div>

    <hr class="section-divider">

    <h2 id="prompt-eng" class="rv zh">Prompt 工程<em>笔记</em></h2>
    <h2 class="rv en">Prompt Engineering <em>Notes</em></h2>

    <div class="diagram rv"><span class="hl">[Role]</span>      → Music expert DJ, driving playlists
<span class="hl">[Profile]</span>   → All TasteProfile fields
<span class="hl">[Behavior]</span>  → Enjoyed songs (with duration) + Skipped songs
<span class="hl">[Blocklist]</span> → Full already-played list
<span class="hl">[Rules]</span>     → Recommendation constraints</div>

    <h3 class="rv zh">实践中踩过的坑</h3>
    <h3 class="rv en">Lessons Learned</h3>

    <div class="insight-grid zh">
      <div class="insight-card rv"><h4>不要让 AI 更新 profile</h4><p>会导致品味漂移。连续跳几首慢歌 → "Chill" 标签消失 → 再也推不出慢歌。</p></div>
      <div class="insight-card rv"><h4>不要用 temperature=0</h4><p>推荐极度单调——每次推相同风格。0.9 是甜蜜点。</p></div>
      <div class="insight-card rv"><h4>不要省略 already played</h4><p>AI 没有跨调用记忆。不传完整列表，第 3 轮就开始重复。</p></div>
      <div class="insight-card rv"><h4>指令不要太细</h4><p>"必须包含一首 2000 年代的歌" 之类硬规则让推荐变机械。"Adapt and surprise them" 更有效。</p></div>
    </div>
    <div class="insight-grid en">
      <div class="insight-card rv"><h4>Don't let AI update the profile</h4><p>Causes taste drift. Skip a few slow songs → "Chill" tag disappears → never recommends slow songs again.</p></div>
      <div class="insight-card rv"><h4>Don't use temperature=0</h4><p>Recommendations become monotonous — same style every time. 0.9 is the sweet spot.</p></div>
      <div class="insight-card rv"><h4>Don't omit already played</h4><p>The AI has no cross-call memory. Without the full list, it starts repeating by round 3.</p></div>
      <div class="insight-card rv"><h4>Don't over-specify rules</h4><p>"Must include one 2000s song" makes recommendations feel mechanical. "Adapt and surprise them" works better.</p></div>
    </div>

    <hr class="section-divider">

    <h2 id="tradeoffs" class="rv">Trade-offs</h2>

    <p class="rv zh">用 LLM 做推荐引擎是非常规路线。以下是诚实的优劣对比：</p>
    <p class="rv en">Using an LLM as the recommendation engine is unconventional. Here's an honest comparison:</p>

    <table class="article-table rv zh">
      <thead><tr><th>维度</th><th>LLM (Tunes)</th><th>传统推荐</th></tr></thead>
      <tbody>
        <tr><td>冷启动</td><td class="win">零——一个歌单即可</td><td class="lose">需大量用户数据</td></tr>
        <tr><td>可解释性</td><td class="win">自然语言推荐理由</td><td class="lose">不透明的分数</td></tr>
        <tr><td>实时适应</td><td class="win">通过 prompt 上下文</td><td class="lose">需要重训模型</td></tr>
        <tr><td>延迟</td><td class="lose">~2s / 批次</td><td class="win">亚毫秒查询</td></tr>
        <tr><td>一致性</td><td class="lose">非确定性</td><td class="win">可复现排序</td></tr>
        <tr><td>音乐知识</td><td class="win">内置世界知识</td><td class="lose">只知训练数据</td></tr>
      </tbody>
    </table>
    <table class="article-table rv en">
      <thead><tr><th>Dimension</th><th>LLM (Tunes)</th><th>Traditional RecSys</th></tr></thead>
      <tbody>
        <tr><td>Cold start</td><td class="win">Zero — works from 1 playlist</td><td class="lose">Needs massive user data</td></tr>
        <tr><td>Explainability</td><td class="win">Natural language reasons</td><td class="lose">Opaque similarity scores</td></tr>
        <tr><td>Adaptability</td><td class="win">Real-time via prompt context</td><td class="lose">Requires model retraining</td></tr>
        <tr><td>Latency</td><td class="lose">~2s per batch</td><td class="win">Sub-millisecond lookups</td></tr>
        <tr><td>Consistency</td><td class="lose">Non-deterministic</td><td class="win">Reproducible rankings</td></tr>
        <tr><td>Music knowledge</td><td class="win">World knowledge built in</td><td class="lose">Only knows training data</td></tr>
      </tbody>
    </table>

    <div class="callout coral rv">
      <b class="zh">结论：</b><b class="en">Verdict:</b>
      <span class="zh">对于单用户的个人工具，LLM 方案全面碾压。零基础设施、即时冷启动、自然语言反馈。劣势只在百万用户规模时才成问题。</span>
      <span class="en">For a single-user personal tool, the LLM approach wins hands down. Zero infrastructure, instant cold start, natural language feedback. The trade-offs only matter at scale — and this isn't meant to be Spotify.</span>
    </div>

    <hr class="section-divider">

    <h2 id="conclusion" class="rv zh"><em>总结</em></h2>
    <h2 class="rv en"><em>Conclusion</em></h2>

    <div class="diagram rv"><span class="hl zh">好的推荐</span><span class="hl en">Great recs</span> = <span class="zh">精准的品味画像</span><span class="en">Precise taste profile</span>
          + <span class="zh">实时的行为反馈</span><span class="en">Real-time behavioral feedback</span>
          + <span class="zh">高创造性的 LLM</span><span class="en">Creative LLM</span></div>

    <p class="rv zh">传统推荐系统的复杂性——协同过滤、embedding、特征工程、模型训练——在个人场景下全部是过度工程。一个好的 prompt、一个结构化输出 schema、一个行为反馈闭环。就这些。</p>
    <p class="rv en">The complexity of traditional recommendation systems — collaborative filtering, embeddings, feature engineering, model training — is all over-engineering for a personal use case. A good prompt, a structured output schema, and a behavioral feedback loop. That's all you need.</p>

    <p class="rv zh">如果你也想搭一个自己的推荐系统，不要从 TensorFlow 开始。从一个 prompt 开始。</p>
    <p class="rv en">If you want to build your own recommendation system, don't start with TensorFlow. Start with a prompt.</p>

    <div class="callout rv">
      <b>Try it:</b> <a href="https://tunes.ning.codes" target="_blank">tunes.ning.codes</a> · <a href="https://tunes.ning.codes/showcase.html" target="_blank">Technical Showcase</a>
    </div>

  </article>

  <footer class="page-footer">
    <span>&copy; 2025 Ning</span>
    <span class="made"><span class="heart"></span> vibed into existence</span>
  </footer>
</div>

<script>
const obs = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) { e.target.classList.add('v'); obs.unobserve(e.target); } });
}, { threshold: 0.08 });
document.querySelectorAll('.rv').forEach(el => obs.observe(el));

// Language toggle
const toggle = document.getElementById('langToggle');
let lang = 'zh';
toggle.addEventListener('click', function() {
  lang = lang === 'zh' ? 'en' : 'zh';
  document.documentElement.classList.toggle('lang-en', lang === 'en');
  toggle.textContent = lang === 'zh' ? 'EN' : '中文';
});
</script>
</body>
</html>
